/*
 * Copyright 2016 CSIRO
 *
 * This file is part of Mastik.
 *
 * Mastik is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Mastik is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Mastik.  If not, see <http://www.gnu.org/licenses/>.
 */
#define _GNU_SOURCE

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdbool.h>
#include <signal.h>
#include <string.h>
#include <util.h>
#include <l3.h>
#include <low.h>

#include <time.h>
#include <sched.h>
#include "vlist.h"

#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>

#ifdef MAP_HUGETLB
#define HUGEPAGES MAP_HUGETLB
#endif

//colours
#define KNRM  "\x1B[0m"
#define KRED  "\x1B[31m"
#define KGRN  "\x1B[32m"
#define KYEL  "\x1B[33m"
#define KBLU  "\x1B[34m"
#define KMAG  "\x1B[35m"
#define KCYN  "\x1B[36m"
#define KWHT  "\x1B[37m"

//Parameters
#define NSETS 8192
#define NUM_OF_ACTIVE_SETS 300
#define LINES_PER_SET 12

//Sampling Parameter
#define SAMPLES_FOR_RANKING 5000
#define SAMPLES_FOR_ATTACKER 5000
#define ATTACKER_PHASES 20
#define RANKING_PHASES 10
#define INTERVAL_DEF 6666
#define SPECIFICSET_SAMPLES 500000
#define SPECIFICSET_SAMPLES_LONG (SPECIFICSET_SAMPLES * 5)
#define INPUTSIZE 				100
#define RUMBLE_CORE_0 	0
#define RUMBLE_CORE_1 	1
#define SIGNAL_CORE 	2
#define ATTACKER_CORE 	3

#define SIGNAL_ACTIVE_INTERVAL_DEF 100000
#define SIGNAL_SLEEP_INTERVAL_DEF 100000
#define NUM_OF_SIGNAL_CYCLES_DEF 20

#define EXPERIMENT_RUNS 20
#define STRIDE_BUFFSIZE (50*1024*1024)//50 MB
#define STRIDE_LINES 30000
sig_atomic_t doNoise = 0,doSignal = 0;

l3pp_t l3;
l3pp_t l3_test;
char * buffer;
bool *ActiveSets = NULL;
int NumOfActiveSets = 0;
int nsets = 0;
int setsPerSlice = 0;
int probensity,probethresh,rumbleOpt;
int setForProbe;
int INTERVAL = INTERVAL_DEF;
int SIGNAL_ACTIVE_INTERVAL = SIGNAL_ACTIVE_INTERVAL_DEF;
int SIGNAL_SLEEP_INTERVAL = SIGNAL_SLEEP_INTERVAL_DEF;
int NUM_OF_SIGNAL_CYCLES = NUM_OF_SIGNAL_CYCLES_DEF;
int nslices = 0;
int automated = false;
int  rumbleArgs[5] = {0};
int  rumbleArgs2[5] = {0};
int fileNum = 0;
char input[INPUTSIZE];
char *token;
char str [INPUTSIZE*10];
char path [INPUTSIZE*10];
struct stat st = {0};


uint16_t *specific_res;
uint64_t *specific_res_times_before,*specific_res_times_after;
char ** lines;
char test;
pthread_t rumble_tid_1,rumble_tid_2,signal_tid;
char signalFileName [100];
char *result_filename;
char *result_times_before_filename;
char *result_times_after_filename;

uint64_t EvictLLC(l3pp_t l3){
	int k = 0;
	uint64_t tic,toc;
	for(int i = 0; i < nsets; i ++){
		for (int j = 0; j < LINES_PER_SET; j ++){
			lines[k] = l3_getline(l3,i,j);
			k++;
		}
	}

	tic = rdtscp64();
	for (int i = 0; i < nsets * LINES_PER_SET; i ++){
		memaccess(lines[i]);
	}
	toc = rdtscp64() - tic;

	return toc;
}
void pinToCore(int coreId){
	int rs;
	cpu_set_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(coreId, &cpuset);
	rs = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
	if (rs) {
		perror("pthread_setaffinity_np");
		exit(EXIT_FAILURE);
	}
}

//just bf - the previous function is below
void *rumble(void* args){
	FILE * noisetimes = fopen("noisetimes.txt", "a");
	int * prms = (int*)args;
	int coreNum = prms[0];
	int lineOffset = prms[1];
	int intensity = prms[2];
	int isComplementTo = (intensity<100) ?  intensity > 12 : 0;
	uint8_t IsFlipping = intensity==136;
	uint8_t evenFlip = 0;
	intensity = intensity % 13;
	if(IsFlipping){
		intensity=7;
	}
	fprintf(noisetimes,"start %d\n",coreNum);
	fflush(noisetimes);
	printf("Rumble intensity: %d, lineOffset: %d\n", intensity ,lineOffset);

	//coreNum = isComplementTo ? RUMBLE_CORE_1 : RUMBLE_CORE_0;

	//if (isComplementTo){
	//	printf("not supported");
	//	exit(0);
	//}


	if (!intensity){
		return NULL;
	}

	pinToCore(coreNum);
	if (!NumOfActiveSets) {
		printf("Nothing to Rumble!\n");
		fflush(stdout);
		doNoise = 0;
		return (void*) EXIT_SUCCESS;
	}



	char ** lines_arr = calloc(sizeof(char*),(intensity * NumOfActiveSets));

	int k = 0;
	int setForProbe = -1;
	if (isComplementTo){
		for (int i = 0; i < intensity; i++){
			for (int j = 0; j < nsets; j++) {
				if (ActiveSets[j]){
					if(setForProbe==-1){
						setForProbe = j;
					}else{
						lines_arr[k] = l3_getline(l3, j, i+lineOffset);
						k++;
					}
				}
			}
		}
	} else {
		for (int i = 0; i < intensity; i++){
			for (int j = 0; j < nsets; j++) {
				if (ActiveSets[j]){
					lines_arr[k] = l3_getline(l3, j, i+lineOffset);
					k++;
				}
			}
		}
	}

	void * p;
	if(isComplementTo)
		p = sethead(l3,setForProbe);
	int flip = 0;
	int calc;
	fprintf(noisetimes,"on,%li,%d\n",rdtscp64(),coreNum);
	fflush(noisetimes);
	if(IsFlipping){
		intensity=6;
	}
	if(!isComplementTo){
		while (doNoise) {
			evenFlip=!evenFlip;
			calc = (NumOfActiveSets) * (intensity+(evenFlip&IsFlipping));

			for (int i = 0; i < calc; i++) {
				memaccess(lines_arr[i]);
			}
		}
	}else{
		while (doNoise) {
			int i, r;
			flip = !flip;
			r = flip ? probecount(p) : bprobecount(p);
			r = (r ? 1 : 0);
			for (i = 0; i < (NumOfActiveSets-1) * (intensity-r); i++) {
				memaccess(lines_arr[i]);
			}
		}	
	}

	fprintf(noisetimes,"off,%li,%d\n",rdtscp64(),coreNum);
	fflush(noisetimes);
	fclose(noisetimes);
	free(lines_arr);
	return (void*) EXIT_SUCCESS;
}

void *rumble_arbel(void* args){

	int * prms = (int*)args;
	int coreNum = prms[0];
	int lineOffset = prms[1];
	int intensity = prms[2];
	int probensity = prms[3];
	int probethresh = prms[4];
	int isComplementTo = intensity > 12;
	int isPhase = (probethresh>=0);
	int twoComp = (probensity<=0);
	printf("Rumble intensity: %d, lineOffset: %d,  probensity: %d, probethresh: %d\n", intensity ,lineOffset,prms[3] ,prms[4]);
	//coreNum = isComplementTo ? RUMBLE_CORE_1 : RUMBLE_CORE_0;

	if (isComplementTo){
		printf("not supported");
		exit(0);
	}


	if (!intensity){
		return NULL;
	}

	intensity = intensity%13;

	pinToCore(coreNum);
	if (!NumOfActiveSets) {
		printf("Nothing to Rumble!\n");
		fflush(stdout);
		doNoise = 0;
		return (void*) EXIT_SUCCESS;
	}


	char ** lines_arr = calloc(sizeof(char*),(intensity * NumOfActiveSets));

	int k = 0;
	int setForProbe = -1;
	for (int j = 0; j < nsets; j++){
		if (ActiveSets[j]){
			if(lineOffset==0){
				setForProbe = j;
				break;
			}else{
				if(k==1){
					setForProbe = j;
					break;
				}else{
					k++;
				}
			}
		}
	}

	k = 0;
	int count = 0;
	if(isPhase){
		for (int i = 0; i < intensity; i++) {
			for (int j = 0; j < nsets; j++){
				if (ActiveSets[j]){
					if(count>=2){
						lines_arr[k] = l3_getline(l3, j, i+lineOffset);
						k++;
					}else{
						count++;
					}
				}
			}
		}
	}else{
		for (int j = 0; j < nsets; j++) {
			for (int i = 0; i < intensity; i++){
				if (ActiveSets[j]){
					if(count>=2){
						lines_arr[k] = l3_getline(l3, j, i+lineOffset);
						k++;
					}else{
						count++;
					}
				}
			}
		}
	}
	void * p = sethead(l3,setForProbe);
	int flip = 0;
	int ind = 0;

	int counter = 0;
	int nlinesToNoise = 0;


	if (isComplementTo){
		while (doNoise) {
			int i, r;
			flip = !flip;
			r = flip ? probecount(p) : bprobecount(p);
			r = (r ? 1 : 0);
			for (i = 0; i < (NumOfActiveSets-2) * (intensity-r); i++) {
				memaccess(lines_arr[i]);
			}
		}
	} else {

		while (doNoise) {
			for (int i = 0; i < (NumOfActiveSets) * (intensity); i++) {
				memaccess(lines_arr[i]);
			}
		}

	}

	//	while (doNoise) {
	//		int i, dummy, r, cr = 0;
	//		for (i = 0; i < probensity; i++){
	//			flip = !flip;
	//			r = flip ? probecount(p) : bprobecount(p);
	//			cr+= r;
	//		}
	//		if(cr<=probethresh){
	//			for (i = 0; i < (NumOfActiveSets-1) * intensity; i++) {
	//
	//				fflush(stdout);
	//				memaccess(lines_arr[i]);
	//			}
	//		}
	//	}


	//	while (doNoise) {
	//		int i, dummy, r;
	//		flip = !flip;
	//		r = flip ? probecount(p) : bprobecount(p);
	//
	//		nlinesToNoise = r ? 1 : intensity;
	//		for (int i = 0; i < (NumOfActiveSets-1) * nlinesToNoise; i++) {
	//			memaccess(lines_arr[i]);
	//		}
	//	}


	//	while (doNoise) {
	//		int i, r;
	//		for(int j=intensity;j>0;j--){
	//			for (int i = 0; i < (NumOfActiveSets) * (intensity-j); i++) {
	//				memaccess(lines_arr[i]);
	//			}
	//		}
	//
	//	}
	//
	//
	//
	//	while (doNoise) {
	//		int i, r;
	//
	//		flip = !flip;
	//		r = flip ? probecount(p) : bprobecount(p);
	//		r = (r ? 1 : 0);
	//		for (int i = 0; i < (NumOfActiveSets-1) * (intensity-r); i++) {
	//			memaccess(lines_arr[i]);
	//		}
	//	}
	//
	//
	//		for (int k = 0; k < 100; k ++){
	//			flip = !flip;
	//			r = flip ? probecount(p) : bprobecount(p);
	//
	//			for (int i = 0; i < (NumOfActiveSets-1) * (intensity-1-r); i++) {
	//				memaccess(lines_arr[i]);
	//			}
	//		}
	//
	//	}


	free(lines_arr);
	return (void*) EXIT_SUCCESS;
}

/*
void* rumble(void* args) {

	pinToCore(RUMBLE_CORE_0);

	printf("intensity = %d, probensity = %d\n", intensity, probensity);
	if (!NumOfActiveSets) {
		printf("Nothing to Rumble!\n");
		fflush(stdout);
		doNoise = 0;
		return (void*) EXIT_SUCCESS;
	}
	if (ActiveSets[setForProbe]){
		printf("Error : setForProbe is in suspected list, press 7 and remove it\n");
		fflush(stdout);
		doNoise = 0;
		return (void*) EXIT_SUCCESS;
	}

	char ** lines = calloc(NumOfActiveSets*intensity, sizeof(char *));

	int k = 0;
	for (int i = 0; i < intensity; i++) {
		for (int j = 0; j < nsets; j++){
			if (ActiveSets[j]){
				lines[k] = l3_getline(l3, j, i);
				k++;
			}
		}
	}
	void * p = sethead(l3,setForProbe);
	int flip = 0;
	int ind = 0;
	if (rumbleOpt == 0){
		while (doNoise) {
			int i, dummy, r;
			flip = !flip;
			r = flip ? probecount(p) : bprobecount(p);

			for (i = 0; i < NumOfActiveSets * (intensity-r); i++) {
				if (1 == lines[i][0])
					dummy++;
			}
		}
	} else if (rumbleOpt == 1){
		while (doNoise) {
			int i, dummy, r, cr = 0;
			for (i = 0; i < probensity; i++){
				r = probecount(p);
				cr+= r;
			}
			if(cr<=probethresh){
				for (i = 0; i < NumOfActiveSets * intensity; i++) {
					if (1 == lines[i][0])
						dummy++;
				}
			}
		}
	} else if (rumbleOpt == 2){
		while (doNoise) {
			int i, dummy, r, cr = 0;
			for (i = 0; i < probensity; i++){
				flip = !flip;
				r = flip ? probecount(p) : bprobecount(p);
				cr+= r;
			}
			if(cr<=probethresh){
				for (i = 0; i < NumOfActiveSets * intensity; i++) {
					if (1 == lines[i][0])
						dummy++;
				}
			}
		}
	}
	free(lines);
	return (void*) EXIT_SUCCESS;
}
 */
int writeSignalTimesToFile = false;
void* signalActiveLines(void* args) {
	int rs;
	if (stat("./results", &st) == -1) {
		mkdir("./results", 0700);
	}
	char tmpfilename[100];
	strcpy(tmpfilename,signalFileName);
	if(automated)
		sprintf(signalFileName,"%s",tmpfilename);
	printf("signaling, saving results at: %s\n",signalFileName);
	printf("pid %d",getpid());
	FILE * ftimes;
	if (writeSignalTimesToFile)
		ftimes = fopen(signalFileName,"w+");

	//struct timespec sleepValue = {0};
	//sleepValue.tv_nsec = 5000000L;
	int i,j,x;

	pinToCore(SIGNAL_CORE);

	for (i = 0, j = 0; j < nsets; j++){
		if (ActiveSets[j]){
			lines[i] = l3_getline(l3, j, 0);
			i++;
		}
	}

//	int SecretMsg[50] = {1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1};
//	int SecretInd = 0;
	//int dummy;
	uint64_t t1,t2,startTime;
	while(doSignal){
		//		for (j = 0; j < 1000; j++){
		//Active Time (Make Misses)
		startTime = rdtscp64();
		t1 = 0;
		while(t1 < SIGNAL_ACTIVE_INTERVAL){
			//			printf("a");
			for (i = 0; i < NumOfActiveSets; i++){
				memaccess(lines[i]);
				//				__builtin_prefetch(lines[i]);
			}
			t1 = rdtscp64() - startTime;
		}

		//Sleep Time
		//		printf("*");
		if (writeSignalTimesToFile)
			fprintf(ftimes,"%li %li, ", startTime, t1+startTime);
		slotwait(t1 + startTime + SIGNAL_SLEEP_INTERVAL);
		//			startTime = rdtscp64();
		//			t1 = (t1-SIGNAL_ACTIVE_INTERVAL);
		//			t2 = 0;
		//			x = t1/SIGNAL_SLEEP_INTERVAL;
		//			while(t2 < (int64_t)(SIGNAL_SLEEP_INTERVAL - t1) + x*SIGNAL_SLEEP_INTERVAL){
		//				t2 = rdtscp64() - startTime;
		//			}
		//		}
		//		nanosleep(&sleepValue,NULL);

	}
	if (writeSignalTimesToFile)
		fclose(ftimes);
}

//test for gabi, regular function is below
void* signalActiveLines_viaForloop(void* args) { //with secret message
	int rs;
	if (stat("./results", &st) == -1) {
		mkdir("./results", 0700);
	}
	char tmpfilename[100];
	strcpy(tmpfilename,signalFileName);
	if(automated)
		sprintf(signalFileName,"%s",tmpfilename);
	printf("signaling, saving results at: %s\n",signalFileName);
	FILE * ftimes;
	if (writeSignalTimesToFile)
		ftimes = fopen(signalFileName,"w+");

	//struct timespec sleepValue = {0};
	//sleepValue.tv_nsec = 5000000L;
	int i,j,x;

	pinToCore(SIGNAL_CORE);

	for (i = 0, j = 0; j < nsets; j++){
		if (ActiveSets[j]){
			lines[i] = l3_getline(l3, j, 0);
			i++;
		}
	}

//	{1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1}
//	{2, 1, 4, 1, 1, 1, 4, 1, 2, 1, 1, 3, 2, 3, 1, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 3, 1, 3, 2, 1, 1, 2, 2, 1, 1, 2, 3, 1, 1, 1, 4, 1, 4, 1, 1, 1, 3, 1, 3, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 1, 4, 3, 1, 3, 1, 3, 1, 1, 7, 1, 5, 3, 1, 4, 2, 1, 1, 1, 1, 2, 1, 1, 3, 2, 2, 2, 2, 5, 1, 1, 2, 6, 3, 3, 2, 5, 1, 1, 1, 1, 1, 3, 4, 1, 2, 1, 4, 1, 7, 2, 3, 2, 3, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 3, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 1, 5, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 2, 3, 6, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1, 3, 2, 1, 2, 1, 1, 1, 6, 4, 1, 2, 2, 4, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 3, 2, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 3, 2, 2, 4, 1, 2, 1, 4, 5, 3, 3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 5, 3, 1, 1, 2, 2, 1, 6, 3, 2, 1, 3, 2, 1, 1, 4, 3, 5, 2, 4, 1, 1, 4, 1, 5, 1, 1, 3, 1, 1, 1, 1, 1, 2, 2, 4, 1, 1, 1, 9, 4, 2, 3, 4, 2, 3, 2, 1, 1, 5, 4, 3, 4, 1, 1, 4, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 4, 2, 2, 3, 4, 4, 1, 1, 3, 2, 1, 1, 2, 1, 1, 1, 4, 2, 3, 1, 1, 4, 2, 1, 3, 7, 3, 6, 3, 2, 2, 3, 2, 1, 5, 1, 2, 4, 3, 1, 4, 1, 2, 6, 1, 7, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 2, 1, 1, 1, 3, 3, 1, 4, 9, 1, 1, 1, 2, 3, 1, 1, 1, 1, 2, 3, 1, 1, 2, 4, 1, 1, 8, 4, 4, 1, 1, 3, 1, 1, 5, 3, 2, 2, 2, 1, 4, 1, 2, 4, 1, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 1, 4, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 1, 1, 2, 1, 2, 3, 4, 1, 1, 1, 5, 2, 1, 7, 2, 4, 2, 3, 2, 1, 1, 2, 6, 2, 1, 1, 1, 2, 3, 2, 3, 1, 1, 1, 1, 3, 3, 2, 7, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 3, 1, 3, 6, 1, 1, 3, 5, 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 2, 5, 1, 1, 1, 1, 1, 3, 1, 2, 5, 2, 2, 2, 1, 1, 4, 1, 1, 2, 1, 1, 2, 5, 2, 2, 1, 1, 1, 1, 3, 1, 1, 2, 3, 1, 7, 1, 1, 1, 1, 1, 3, 3, 1, 1, 5, 3, 1, 1, 5, 1, 2, 1, 1, 2, 1, 1, 2, 6, 5, 2, 1, 2, 3, 1, 2, 2, 1, 5, 1, 1, 1, 1, 1, 5, 1, 4, 2, 1, 3, 6, 1, 1, 1, 2, 4, 4, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 2, 3, 1, 4, 1, 1, 1, 2, 1, 3, 2, 1, 1, 4, 1, 1, 2, 5, 1, 3, 1, 1, 2, 1, 1, 1, 4, 2, 1, 6, 2, 1, 4, 1, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 2, 1, 1, 1, 1, 4, 2, 1, 4, 4, 1, 1, 1, 1, 2, 5, 1, 4, 2, 2, 4, 1, 1, 3, 2, 1, 1, 1, 1, 1, 7, 2, 3, 1, 1, 1, 3, 4, 1, 2, 1, 2, 2, 3, 1, 1, 4, 7, 2, 1, 3, 1, 4, 1, 3, 1, 1, 2, 3, 1, 1, 2, 2, 2, 4, 2, 2, 1, 1, 2, 1, 2, 3, 5, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 3, 3, 1, 6, 1, 2, 1, 1, 3, 1, 1, 1, 8, 1, 3, 4, 1, 6, 1, 2, 1, 1, 4, 3, 3, 1, 1, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1, 2, 3, 2, 4, 2, 2, 4, 6, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 4, 1, 2, 2, 1, 1, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 1, 6, 1, 1, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 5, 1, 1, 1, 5, 1, 2, 3, 3, 5, 3, 3, 4, 1, 1, 3, 1, 1, 2, 1, 10, 1, 2, 1, 2, 2, 1, 3, 1, 2, 1, 1, 5, 1, 1, 2, 1, 2, 1, 1, 2, 4, 1, 2, 1, 1, 1, 1, 3, 1, 2, 1, 3, 1, 3, 2, 2, 6, 8, 3, 1, 1, 1, 2, 2, 2, 1, 4, 2, 2, 2, 2, 1, 2, 1, 3, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 4, 2, 1, 1, 4, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 3, 4, 1, 1, 2, 1, 1, 1, 2, 4, 2, 1, 1, 2, 1, 2, 4, 4, 1, 1, 1}
//	{1, 1, 1, 4, 7, 8, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 4, 2, 1, 1, 1, 4, 2, 2, 2, 4, 4, 1, 1, 4, 3, 7, 2, 1, 1, 1, 1, 1, 3, 2, 1, 3, 1, 1, 1, 4, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 1, 1, 2, 1, 2, 5, 3, 1, 4, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 1, 2, 2, 7, 1, 5, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 5, 1, 2, 3, 2, 2, 2, 1, 3, 4, 3, 1, 4, 1, 2, 1, 6, 1, 2, 4, 1, 3, 5, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 2, 1, 1, 2, 3, 1, 2, 2, 1, 1, 1, 4, 3, 4, 4, 3, 3, 2, 3, 2, 1, 5, 1, 1, 1, 5, 1, 1, 1, 4, 1, 3, 2, 1, 3, 1, 2, 3, 1, 1, 3, 2, 4, 2, 1, 1, 4, 1, 1, 1, 4, 1, 1, 1, 2, 5, 1, 1, 1, 1, 8, 3, 1, 2, 1, 2, 1, 2, 2, 4, 2, 4, 2, 2, 2, 2, 3, 2, 1, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 2, 1, 3, 1, 2, 1, 1, 5, 1, 1, 2, 1, 2, 1, 1, 1, 4, 3, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 4, 1, 3, 3, 1, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 6, 1, 3, 5, 2, 1, 2, 2, 1, 3, 4, 1, 2, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 1, 2, 6, 2, 5, 2, 6, 1, 1, 5, 5, 1, 1, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 4, 1, 1, 1, 7, 1, 2, 2, 2, 3, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1, 4, 1, 1, 1, 1, 1, 4, 1, 1, 3, 1, 3, 6, 1, 3, 1, 2, 2, 4, 2, 2, 1, 1, 1, 2, 1, 1, 5, 1, 3, 1, 1, 1, 3, 3, 6, 3, 1, 2, 2, 5, 3, 1, 4, 1, 1, 1, 2, 1, 3, 2, 2, 4, 1, 2, 1, 2, 3, 1, 2, 6, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 3, 3, 1, 1, 3, 4, 1, 3, 4, 4, 2, 1, 2, 3, 4, 5, 3, 2, 1, 1, 1, 3, 1, 2, 6, 2, 4, 1, 4, 2, 1, 3, 1, 5, 1, 1, 1, 2, 1, 2, 1, 1, 1, 3, 2, 2, 1, 1, 6, 1, 2, 2, 1, 1, 1, 2, 2, 3, 1, 1, 2, 2, 6, 1, 1, 2, 1, 4, 1, 2, 2, 2, 3, 1, 2, 1, 1, 2, 2, 1, 1, 1, 4, 3, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 2, 2, 4, 3, 2, 2, 1, 1, 1, 1, 1, 6, 4, 1, 3, 5, 1, 1, 1, 1, 1, 1, 2, 7, 4, 1, 5, 1, 1, 1, 6, 1, 2, 3, 1, 2, 1, 2, 1, 2, 2, 1, 1, 6, 2, 1, 1, 2, 2, 1, 4, 1, 2, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 3, 1, 5, 3, 2, 1, 1, 2, 2, 8, 3, 6, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 1, 2, 6, 2, 4, 2, 1, 1, 3, 3, 1, 1, 1, 1, 2, 3, 2, 1, 1, 1, 2, 1, 1, 4, 1, 2, 1, 1, 2, 2, 1, 3, 1, 2, 1, 2, 1, 6, 4, 1, 2, 2, 1, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 3, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 4, 4, 1, 2, 5, 2, 2, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 6, 1, 2, 1, 1, 1, 1, 1, 2, 3, 2, 2, 5, 1, 2, 1, 1, 2, 2, 1, 1, 2, 1, 4, 1, 1, 2, 7, 2, 1, 1, 1, 2, 3, 1, 2, 2, 4, 1, 2, 3, 5, 2, 1, 11, 1, 5, 3, 3, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 3, 3, 2, 1, 2, 1, 1, 1, 1, 4, 1, 1, 2, 2, 1, 2, 3, 1, 1, 3, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 4, 3, 1, 2, 2, 2, 1, 6, 2, 1, 1, 1, 2, 7, 4, 3, 3, 2, 1, 1, 1, 2, 1, 1, 3, 5, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 5, 1, 1, 1, 1, 2, 2, 1, 3, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 4, 1, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 3, 3, 3, 1, 4, 2, 3, 2, 1, 2, 4, 2, 3, 1, 2, 1, 1, 3, 1, 4, 3, 3, 3, 2, 4, 1, 3, 6, 1, 2, 3, 1, 2, 1, 3, 2, 1, 4, 5, 1, 1, 2, 1, 1, 2, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1, 2, 1, 8, 3, 2, 1, 1, 1, 3, 1, 2, 1, 3, 2, 4, 2, 2, 1, 3, 1, 1, 3, 3, 1, 4, 2, 2, 3, 1, 1, 2, 1, 1, 4, 1, 1, 1, 3, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1}


	int SecretMsg[4096] = {1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1};
	int SecretOnes[1036] = {2, 1, 4, 1, 1, 1, 4, 1, 2, 1, 1, 3, 2, 3, 1, 3, 3, 1, 1, 1, 3, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 3, 1, 3, 2, 1, 1, 2, 2, 1, 1, 2, 3, 1, 1, 1, 4, 1, 4, 1, 1, 1, 3, 1, 3, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 1, 1, 4, 3, 1, 3, 1, 3, 1, 1, 7, 1, 5, 3, 1, 4, 2, 1, 1, 1, 1, 2, 1, 1, 3, 2, 2, 2, 2, 5, 1, 1, 2, 6, 3, 3, 2, 5, 1, 1, 1, 1, 1, 3, 4, 1, 2, 1, 4, 1, 7, 2, 3, 2, 3, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 3, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1, 1, 2, 1, 3, 2, 1, 1, 5, 2, 3, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 2, 3, 6, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1, 3, 2, 1, 2, 1, 1, 1, 6, 4, 1, 2, 2, 4, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 3, 2, 1, 1, 3, 1, 1, 2, 1, 2, 3, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 3, 2, 2, 4, 1, 2, 1, 4, 5, 3, 3, 1, 2, 2, 1, 2, 2, 2, 3, 1, 5, 3, 1, 1, 2, 2, 1, 6, 3, 2, 1, 3, 2, 1, 1, 4, 3, 5, 2, 4, 1, 1, 4, 1, 5, 1, 1, 3, 1, 1, 1, 1, 1, 2, 2, 4, 1, 1, 1, 9, 4, 2, 3, 4, 2, 3, 2, 1, 1, 5, 4, 3, 4, 1, 1, 4, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 4, 2, 2, 3, 4, 4, 1, 1, 3, 2, 1, 1, 2, 1, 1, 1, 4, 2, 3, 1, 1, 4, 2, 1, 3, 7, 3, 6, 3, 2, 2, 3, 2, 1, 5, 1, 2, 4, 3, 1, 4, 1, 2, 6, 1, 7, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 3, 2, 2, 1, 1, 1, 3, 3, 1, 4, 9, 1, 1, 1, 2, 3, 1, 1, 1, 1, 2, 3, 1, 1, 2, 4, 1, 1, 8, 4, 4, 1, 1, 3, 1, 1, 5, 3, 2, 2, 2, 1, 4, 1, 2, 4, 1, 1, 3, 2, 2, 1, 2, 2, 1, 3, 1, 1, 1, 1, 1, 1, 4, 3, 2, 1, 1, 2, 1, 3, 2, 3, 2, 1, 1, 2, 1, 2, 3, 4, 1, 1, 1, 5, 2, 1, 7, 2, 4, 2, 3, 2, 1, 1, 2, 6, 2, 1, 1, 1, 2, 3, 2, 3, 1, 1, 1, 1, 3, 3, 2, 7, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 3, 1, 3, 6, 1, 1, 3, 5, 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 2, 5, 1, 1, 1, 1, 1, 3, 1, 2, 5, 2, 2, 2, 1, 1, 4, 1, 1, 2, 1, 1, 2, 5, 2, 2, 1, 1, 1, 1, 3, 1, 1, 2, 3, 1, 7, 1, 1, 1, 1, 1, 3, 3, 1, 1, 5, 3, 1, 1, 5, 1, 2, 1, 1, 2, 1, 1, 2, 6, 5, 2, 1, 2, 3, 1, 2, 2, 1, 5, 1, 1, 1, 1, 1, 5, 1, 4, 2, 1, 3, 6, 1, 1, 1, 2, 4, 4, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 2, 3, 1, 4, 1, 1, 1, 2, 1, 3, 2, 1, 1, 4, 1, 1, 2, 5, 1, 3, 1, 1, 2, 1, 1, 1, 4, 2, 1, 6, 2, 1, 4, 1, 1, 3, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 2, 1, 1, 1, 1, 4, 2, 1, 4, 4, 1, 1, 1, 1, 2, 5, 1, 4, 2, 2, 4, 1, 1, 3, 2, 1, 1, 1, 1, 1, 7, 2, 3, 1, 1, 1, 3, 4, 1, 2, 1, 2, 2, 3, 1, 1, 4, 7, 2, 1, 3, 1, 4, 1, 3, 1, 1, 2, 3, 1, 1, 2, 2, 2, 4, 2, 2, 1, 1, 2, 1, 2, 3, 5, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 3, 1, 1, 3, 3, 1, 6, 1, 2, 1, 1, 3, 1, 1, 1, 8, 1, 3, 4, 1, 6, 1, 2, 1, 1, 4, 3, 3, 1, 1, 1, 1, 1, 3, 2, 1, 2, 1, 1, 1, 2, 3, 2, 4, 2, 2, 4, 6, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 4, 1, 2, 2, 1, 1, 3, 1, 1, 2, 1, 1, 3, 1, 2, 1, 1, 6, 1, 1, 2, 3, 2, 1, 2, 2, 3, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 5, 1, 1, 1, 5, 1, 2, 3, 3, 5, 3, 3, 4, 1, 1, 3, 1, 1, 2, 1, 10, 1, 2, 1, 2, 2, 1, 3, 1, 2, 1, 1, 5, 1, 1, 2, 1, 2, 1, 1, 2, 4, 1, 2, 1, 1, 1, 1, 3, 1, 2, 1, 3, 1, 3, 2, 2, 6, 8, 3, 1, 1, 1, 2, 2, 2, 1, 4, 2, 2, 2, 2, 1, 2, 1, 3, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1, 1, 4, 2, 1, 1, 4, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 3, 4, 1, 1, 2, 1, 1, 1, 2, 4, 2, 1, 1, 2, 1, 2, 4, 4, 1, 1, 1};
	int SecretZeros[1036] = {1, 1, 1, 4, 7, 8, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 4, 2, 1, 1, 1, 4, 2, 2, 2, 4, 4, 1, 1, 4, 3, 7, 2, 1, 1, 1, 1, 1, 3, 2, 1, 3, 1, 1, 1, 4, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 1, 1, 1, 2, 1, 2, 5, 3, 1, 4, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 1, 2, 2, 7, 1, 5, 2, 1, 1, 1, 2, 2, 2, 2, 1, 2, 5, 1, 2, 3, 2, 2, 2, 1, 3, 4, 3, 1, 4, 1, 2, 1, 6, 1, 2, 4, 1, 3, 5, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 2, 1, 1, 2, 3, 1, 2, 2, 1, 1, 1, 4, 3, 4, 4, 3, 3, 2, 3, 2, 1, 5, 1, 1, 1, 5, 1, 1, 1, 4, 1, 3, 2, 1, 3, 1, 2, 3, 1, 1, 3, 2, 4, 2, 1, 1, 4, 1, 1, 1, 4, 1, 1, 1, 2, 5, 1, 1, 1, 1, 8, 3, 1, 2, 1, 2, 1, 2, 2, 4, 2, 4, 2, 2, 2, 2, 3, 2, 1, 1, 1, 2, 1, 2, 1, 2, 3, 1, 1, 2, 2, 1, 3, 1, 2, 1, 1, 5, 1, 1, 2, 1, 2, 1, 1, 1, 4, 3, 1, 3, 3, 2, 2, 1, 1, 2, 3, 2, 4, 1, 3, 3, 1, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 6, 1, 3, 5, 2, 1, 2, 2, 1, 3, 4, 1, 2, 1, 1, 1, 1, 2, 3, 3, 3, 3, 3, 1, 2, 3, 3, 1, 2, 1, 2, 6, 2, 5, 2, 6, 1, 1, 5, 5, 1, 1, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 4, 1, 1, 1, 7, 1, 2, 2, 2, 3, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1, 4, 1, 1, 1, 1, 1, 4, 1, 1, 3, 1, 3, 6, 1, 3, 1, 2, 2, 4, 2, 2, 1, 1, 1, 2, 1, 1, 5, 1, 3, 1, 1, 1, 3, 3, 6, 3, 1, 2, 2, 5, 3, 1, 4, 1, 1, 1, 2, 1, 3, 2, 2, 4, 1, 2, 1, 2, 3, 1, 2, 6, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 1, 3, 3, 1, 1, 3, 4, 1, 3, 4, 4, 2, 1, 2, 3, 4, 5, 3, 2, 1, 1, 1, 3, 1, 2, 6, 2, 4, 1, 4, 2, 1, 3, 1, 5, 1, 1, 1, 2, 1, 2, 1, 1, 1, 3, 2, 2, 1, 1, 6, 1, 2, 2, 1, 1, 1, 2, 2, 3, 1, 1, 2, 2, 6, 1, 1, 2, 1, 4, 1, 2, 2, 2, 3, 1, 2, 1, 1, 2, 2, 1, 1, 1, 4, 3, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 3, 1, 1, 2, 2, 4, 3, 2, 2, 1, 1, 1, 1, 1, 6, 4, 1, 3, 5, 1, 1, 1, 1, 1, 1, 2, 7, 4, 1, 5, 1, 1, 1, 6, 1, 2, 3, 1, 2, 1, 2, 1, 2, 2, 1, 1, 6, 2, 1, 1, 2, 2, 1, 4, 1, 2, 1, 3, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 2, 3, 1, 5, 3, 2, 1, 1, 2, 2, 8, 3, 6, 1, 2, 1, 2, 1, 2, 1, 1, 2, 3, 1, 2, 6, 2, 4, 2, 1, 1, 3, 3, 1, 1, 1, 1, 2, 3, 2, 1, 1, 1, 2, 1, 1, 4, 1, 2, 1, 1, 2, 2, 1, 3, 1, 2, 1, 2, 1, 6, 4, 1, 2, 2, 1, 2, 2, 1, 1, 1, 2, 1, 2, 3, 3, 3, 3, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 4, 4, 1, 2, 5, 2, 2, 1, 2, 1, 2, 1, 3, 1, 1, 3, 1, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 6, 1, 2, 1, 1, 1, 1, 1, 2, 3, 2, 2, 5, 1, 2, 1, 1, 2, 2, 1, 1, 2, 1, 4, 1, 1, 2, 7, 2, 1, 1, 1, 2, 3, 1, 2, 2, 4, 1, 2, 3, 5, 2, 1, 11, 1, 5, 3, 3, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 3, 3, 2, 1, 2, 1, 1, 1, 1, 4, 1, 1, 2, 2, 1, 2, 3, 1, 1, 3, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 4, 3, 1, 2, 2, 2, 1, 6, 2, 1, 1, 1, 2, 7, 4, 3, 3, 2, 1, 1, 1, 2, 1, 1, 3, 5, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 5, 1, 1, 1, 1, 2, 2, 1, 3, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 3, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 4, 1, 2, 2, 1, 3, 1, 3, 1, 1, 1, 2, 1, 3, 3, 3, 1, 4, 2, 3, 2, 1, 2, 4, 2, 3, 1, 2, 1, 1, 3, 1, 4, 3, 3, 3, 2, 4, 1, 3, 6, 1, 2, 3, 1, 2, 1, 3, 2, 1, 4, 5, 1, 1, 2, 1, 1, 2, 1, 1, 3, 2, 3, 2, 1, 1, 1, 1, 2, 1, 8, 3, 2, 1, 1, 1, 3, 1, 2, 1, 3, 2, 4, 2, 2, 1, 3, 1, 1, 3, 3, 1, 4, 2, 2, 3, 1, 1, 2, 1, 1, 4, 1, 1, 1, 3, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1};
    int SecretInd = 0;

	uint64_t t1,t2,startTime;

	//For unit time
	startTime = rdtscp64();
	for (j = 0; j < NUM_OF_SIGNAL_CYCLES; j++){
		for (i = 0; i < NumOfActiveSets; i++){
			memaccess(lines[i]);
		}
	}
	t1 = rdtscp64() - startTime;
	startTime = rdtscp64();
	for (j = 0; j < NUM_OF_SIGNAL_CYCLES; j++){
		for (i = 0; i < NumOfActiveSets; i++){
			memaccess(lines[i]);
		}
	}
	t1 = rdtscp64() - startTime;
	//end

	uint64_t UnitTime = t1*0.25;
	startTime = rdtscp64();
	if (writeSignalTimesToFile)
		fprintf(ftimes,"%li, ", startTime);
	while(doSignal){
		startTime = rdtscp64();
		for(int k=0; k<SecretOnes[SecretInd]; k++){
			for (j = 0; j < NUM_OF_SIGNAL_CYCLES; j++){
				for (i = 0; i < NumOfActiveSets; i++){
					memaccess(lines[i]);
				}
			}
			t1 = rdtscp64() - startTime;
			if (writeSignalTimesToFile)
				fprintf(ftimes,"%li, ", rdtscp64());
		}

		t1 = rdtscp64() - startTime;

		uint64_t zerotime = t1 / SecretOnes[SecretInd];
		//Sleep Time
		for(int k=0; k<SecretZeros[SecretInd]; k++){
			slotwait(startTime + t1+zerotime*(k+1));
			if (writeSignalTimesToFile)
				fprintf(ftimes,"%li, ", rdtscp64());
		}
		SecretInd++;

		if(SecretInd==1036){
			SecretInd=0;
			startTime = rdtscp64();
			slotwait(startTime + UnitTime*100);

			if (writeSignalTimesToFile)
				fprintf(ftimes,"%li, ", startTime+ UnitTime*100);
		}
	}
	if (writeSignalTimesToFile)
		fclose(ftimes);
}


void* signalActiveLines_viaForloop_regural(void* args) {
	int rs;
	if (stat("./results", &st) == -1) {
		mkdir("./results", 0700);
	}
	char tmpfilename[100];
	strcpy(tmpfilename,signalFileName);
	if(automated)
		sprintf(signalFileName,"%s",tmpfilename);
	printf("signaling, saving results at: %s\n",signalFileName);
	FILE * ftimes;
	if (writeSignalTimesToFile)
		ftimes = fopen(signalFileName,"w+");

	//struct timespec sleepValue = {0};
	//sleepValue.tv_nsec = 5000000L;
	int i,j,x;

	pinToCore(SIGNAL_CORE);

	for (i = 0, j = 0; j < nsets; j++){
		if (ActiveSets[j]){
			lines[i] = l3_getline(l3, j, 0);
			i++;
		}
	}


	uint64_t t1,t2,startTime;
	while(doSignal){
		startTime = rdtscp64();

		for (j = 0; j < NUM_OF_SIGNAL_CYCLES; j++){
			for (i = 0; i < NumOfActiveSets; i++){
				memaccess(lines[i]);
			}
		}
		t1 = rdtscp64() - startTime;

		//Sleep Time
		if (writeSignalTimesToFile)
			fprintf(ftimes,"%li %li, ", startTime, t1+startTime);
		slotwait(startTime + 2*t1);

	}
	if (writeSignalTimesToFile)
		fclose(ftimes);
}

void* signalActiveLines_ForNoise(void* args) {

	int rs;
	if (stat("./results", &st) == -1) {
		mkdir("./results", 0700);
	}
	int* prms = (int*)args;

	int rumbleId = prms[0];
	int intensity = prms[1];
	int coreNum;

	coreNum = rumbleId ? RUMBLE_CORE_1 : RUMBLE_CORE_0;
	char tmpfilename[100];
	strcpy(tmpfilename,signalFileName);
	if(automated)
		sprintf(signalFileName,"%s",tmpfilename);
	printf("signaling (for noise, id = %d), saving results at: %s\n",rumbleId,signalFileName);
	FILE * ftimes;

	if (writeSignalTimesToFile)
		ftimes = fopen(signalFileName,"w+");

	//struct timespec sleepValue = {0};
	//sleepValue.tv_nsec = 5000000L;
	int i,j,x;

	pinToCore(coreNum);
	for (int k = 0; k < intensity; k++) {
		for (i = 0, j = 0; j < nsets; j++){
			if (ActiveSets[j]){
				lines[i] = l3_getline(l3, j, k);
				i++;
			}
		}
	}
	//int dummy;
	int64_t t1,t2,startTime,last_rdtscp;
	while(doSignal){

		t2 = rdtscp64();
		startTime = (t2/SIGNAL_ACTIVE_INTERVAL) * SIGNAL_ACTIVE_INTERVAL;
		while (startTime/SIGNAL_ACTIVE_INTERVAL % 2 == rumbleId){
			slotwait(startTime + SIGNAL_ACTIVE_INTERVAL);
			t2 = rdtscp64();
			startTime = (t2/SIGNAL_ACTIVE_INTERVAL) * SIGNAL_ACTIVE_INTERVAL;
		}
		t1 = 0;
		while(t1 < SIGNAL_ACTIVE_INTERVAL){
			for (i = 0; i < NumOfActiveSets*intensity; i++){
				memaccess(lines[i]);
			}
			t1 = rdtscp64() - startTime;
		}
		slotwait(startTime + 2*SIGNAL_ACTIVE_INTERVAL);
		if (writeSignalTimesToFile){
			fprintf(ftimes,"%li %li, ", t2, t1 + startTime);
		}



	}
	if (writeSignalTimesToFile)
		fclose(ftimes);
}
void countMisses(int * dest) {
	uint16_t *res = calloc(SAMPLES_FOR_RANKING, sizeof(uint16_t));

	for (int k = 0; k < RANKING_PHASES; k++){
		for (int i = 0; i < nsets; i++) {
			l3_unmonitorall(l3);
			l3_monitor(l3, i);

			printf("\rMonitor phase %d [%.2f%]", k,	(double) k / RANKING_PHASES * 100);
			fflush(stdout);

			l3_repeatedprobecount(l3, SAMPLES_FOR_RANKING/RANKING_PHASES, res, INTERVAL);

			for (int j = 0; j < SAMPLES_FOR_RANKING/RANKING_PHASES; j++) {
				int16_t r = (int16_t) res[j];
				dest[i] += (r > 0);
			}
		}
	}
	free(res);
}

void CacheMapping(){
	printf("Mapping the Cache!\n");
	fflush(stdout);

	l3 = l3_prepare(NULL);
	l3_test = l3_prepare(NULL);

	if (!l3)
		return EXIT_FAILURE;

	nsets = l3_getSets(l3);

	printf("Mapping Done! Found %d sets\n", nsets);
	fflush(stdout);

	if (nsets != NSETS)
		printf("mapping failure");

	if (!ActiveSets)
		ActiveSets = (bool*) calloc(nsets, sizeof(bool));
	else
		bzero(ActiveSets,nsets * sizeof(bool));

	nslices = l3_getSlices(l3);
	setsPerSlice = nsets / nslices;
}

float monitorSpecificSet(l3pp_t l3, int setToMonitor, char * filename, bool interactive) {
	int zeroCounter;
	uint64_t AvrMiss;
	FILE * f_specificset, * f_specificset_times_before, * f_specificset_times_after;
	if (setToMonitor < 0 || setToMonitor >= nsets) {
		printf("invalid set number!\n");
		return 0;
	}
	//	printf("filename = %s\n", filename);
	CASE5: printf("Monitoring %d...", setToMonitor);
	fflush(stdout);
	f_specificset = fopen(filename, "w+");
	f_specificset_times_before = fopen("specificset_times_before.txt", "w+");
	f_specificset_times_after  = fopen("specificset_times_after.txt" , "w+");
	l3_unmonitorall(l3);
	l3_monitor(l3, setToMonitor);
	//l3_repeatedprobecount(l3, SPECIFICSET_SAMPLES, specific_res, INTERVAL);
	l3_repeatedprobecount_with_times(l3, SPECIFICSET_SAMPLES, specific_res,specific_res_times_after,INTERVAL);

	zeroCounter = 0;
	AvrMiss = 0;
	for (int j = 0; j < SPECIFICSET_SAMPLES; j++) {
		int16_t r = (int16_t) specific_res[j];
		if (r < 13 && r > 0)
			AvrMiss += (uint16_t) r;
		//			printf("%d - %ld, ", (uint16_t) r, AvrMiss);
		if (!r)
			zeroCounter++;
		fprintf(f_specificset, "%d ", r);
		fprintf(f_specificset_times_before, "%li ", specific_res_times_before[j]);
		fprintf(f_specificset_times_after,  "%li ", specific_res_times_after[j]);
	}
	fclose(f_specificset);
	fclose(f_specificset_times_before);
	fclose(f_specificset_times_after);
	printf("\tdone \t avrMiss %.2f\t (%.2f %)!\n", setToMonitor,
			(float) AvrMiss / SPECIFICSET_SAMPLES,
			(float) (zeroCounter) / SPECIFICSET_SAMPLES * 100);
	if (interactive && !automated) {

		printf(
				"RawSet = %d, %d, %d, %d (a - again, n - next, enter - continue)\n",
				setToMonitor % setsPerSlice,
				setToMonitor % setsPerSlice + setsPerSlice,
				setToMonitor % setsPerSlice + 2 * setsPerSlice,
				setToMonitor % setsPerSlice + 3 * setsPerSlice);
		if (fgets(input, INPUTSIZE, stdin) == NULL) {
			perror("input");
		}
		if (input[0] == 'a') {
			goto CASE5;
		} else if (input[0] == 'n') {
			setToMonitor = (setToMonitor + setsPerSlice) % nsets;
			goto CASE5;
		}

	}
	return (float) (zeroCounter) / SPECIFICSET_SAMPLES * 100;
}

int getInput(char * buffer) {
	printf ("> ");
	fflush(stdout);
	int result;
	if (automated){
		token = strtok(buffer, " ");
		result = atoi(token);
		printf("%d\n",result);
		fflush(stdout);

	} else {
		if (fgets(input, INPUTSIZE, stdin) != NULL) {
			result = atoi(input);
		} else
			perror("input");
	}
	return result;
}

void flipPtrArr(void ** arr,int n){
	void * tmp;
	for (int i = 0; i < n/2; i ++){
		tmp = arr[i];
		arr[i] = arr[n-1-i];
		arr[n-1-i] = tmp;
	}
}

void flipIntArr(int * list){
	int tmplist[12];
	for (int i = 0; i < 12; i ++)
		tmplist[i] = list[i];

	list[0]  = tmplist[11];
	list[1]  = tmplist[10];
	list[2]  = tmplist[9];
	list[3]  = tmplist[8];
	list[4]  = tmplist[7];
	list[5]  = tmplist[6];
	list[6]  = tmplist[5];
	list[7]  = tmplist[4];
	list[8]  = tmplist[3];
	list[9]  = tmplist[2];
	list[10] = tmplist[1];
	list[11] = tmplist[0];
}


void checkLRU(){
	delayloop(3000000000U);
	int max = 0;
	int min = 999999;
	int missThr;
	int set = -1;
	int result;
	int results [10000] = {0};
	int newline = 0;
	int misses = 0;
	int inp;
	int func [12] = {0,1,2,3,4,5,6,7,8,9,10,11};
	uint32_t * times = calloc(EXPERIMENT_RUNS*1000,sizeof(uint32_t));
	void** es1 = calloc(12,sizeof(void*));
	void** es2 = calloc(12,sizeof(void*));
	void** es3;
	int count=0;
	int option = 0;
	int ReverseTimes = 0;
	printf("Set?");
	set = getInput(NULL);

	for (int i = 0; i < 12; i ++)		es1[i] = l3_getline(l3,set,i);
	for (int i = 0; i < 12; i ++)		es2[i] = l3_getline(l3_test,set,i);

	printf("How much lines from second set?");
	int secondSetLines = getInput(NULL);
	int i;
	int x = 5;
	int even = 1;
	printf("option?");
	option = getInput(NULL);
	switch(option){
	case 0:

		for (x = 0; x < 12; x++){
			//sleep(1);
			printf("-------------------------------------\n");
			for(int times = 10; times; times--){
				min = 999999;
				//			printf("Press any key to continue...\n");
				//			getInput(NULL);
				for (i = 0; i < 12; i ++){
					clflush(es1[i]);
					clflush(es2[i]);
				}
				printf("%d additional eviction lines from eviction set #2\n",secondSetLines);

				for (i = 0; i < 12; i ++){
					result = memaccesstime(es1[even ? i : 11-i]);
					printf("%d, ",result);
					if (result < min)
						min = result;
				}
				even = ! even;
				//				flipPtrArr(es1,12);
				missThr = min * 0.7;
				printf("Miss Threshold = %d\n",missThr);

				for(int k = 0; k < 111; k++){
					for (i = 0; i < 12; i ++){
						result = memaccesstime(es1[even ? i : 11-i]);
					}
					even = !even;
					//					flipPtrArr(es1,12);
					//				for (i = 0; i < 12/2; i ++){
					//					void * tmp = es1[i];
					//					es1[i] = es1[12-1-i];
					//					es1[12-1-i] = tmp;
					//				}
				}

				for (i = 0; i < secondSetLines ; i++){
					result = memaccesstime(es2[i]);
					printf("%d, ",result);
				}
				printf("\n");
				result = memaccesstime(es1[x]);
				printf("%s%d took %d\n",result > missThr ? KRED : KGRN,x,result);
				printf("%s",KWHT);
			}
		}
		break;
	case 1:

		for (x = 0; x < 12; x++){
			for (i = 0; i < 12; i ++){
				clflush(es1[i]);
				clflush(es2[i]);
			}
			//			sleep(1);
			min = 999999999;
			count = 0;
			for (int k = 0; k < 20; k++){
				for (i = 0; i < 12; i ++){
					if (k){
						result = memaccesstime(es1[func[i]]);
						//						printf("%s%d(%x) ", result > missThr ? KRED : KGRN,result,(uint64_t)es1[func[i]] >> 17 & 0xfff);
						//						for (int imashelcha = 0; imashelcha<1000; imashelcha++){
						printf("%s%d(%x) ", result > missThr ? KRED : KGRN,result,(uint64_t)es1[func[i]] >> 17 & 0xfff);
						//						result = memaccesstime(es1[func[0]]);}
					} else{
						result = memaccesstime(es1[func[i]]);
						printf("%d(%x) ", result,(uint64_t)es1[func[i]] >> 17 & 0xfff);
					}
					if ((result < min) && !k){
						min = result;
						missThr = min * 0.8;
					}
				}

				flipIntArr(func);
				printf("\n");
				fflush(stdout);
				if (!k)
					printf("Threshold for this session = %d\n", missThr);
				//				if (k == EXPERIMENT_RUNS - 1)
				for (i = 0; i < secondSetLines; i++){
					result = memaccesstime(es2[i]);
					printf("%s%d ", result > missThr ? KRED : KGRN,result);
				}
				printf("\n%s",KWHT);
			}
			printf("*****\n");
			//			for (i = 0; i < 5; i ++){
			//				result = memaccesstime(es1[func[i]]);
			//				printf("%s%d(%x) ", result > missThr ? KRED : KGRN,result,(uint64_t)es1[func[i]] >>17 & 0xfff);
			//			}
			for (i = 0; i < secondSetLines; i++){
				result = memaccesstime(es2[i]);
				printf("%s%d ", result > missThr ? KRED : KGRN,result);
			}
			result = memaccesstime(es1[func[x]]);
			printf("\n%s",KWHT);
			printf("\n%d (%x) = %s%d",x,(uint64_t)es1[func[x]] >>17 & 0xfff,result > missThr ? KRED : KGRN,result);
			printf("\n%s",KWHT);

			//			printf("1 - again\n");
			////			if (!getInput(NULL))
			//				x--;
			//			es3 = es2;
			//			es2 = es1;
			//			es1 = es3;

		}

		break;
	case 2:
		CASE2:
		printf("How many reverses?\n");
	ReverseTimes = getInput(NULL);
	for (x = 0; x < 12; x++){
		count = 0;
		for(int k=0; k<100000; k++){
			for (i = 0; i < 12; i ++){
				clflush(es1[i]);
				clflush(es2[i]);
			}

			min = 999999999;
			for (i = 0; i < 12; i ++){
				result = memaccesstime(es1[func[i]]);
				if (result < min){
					min = result;
					missThr = min * 0.8;
				}
			}

			flipIntArr(func);

			for(int j=0; j<ReverseTimes;j++){
				for (i = 0; i < 12; i ++){
					result = memaccesstime(es1[func[i]]);
				}
				flipIntArr(func);
			}

			for (i = 0; i < secondSetLines; i++){
				result = memaccesstime(es2[i]);
			}

			result = memaccesstime(es1[func[x]]);
			count += (result>missThr);
		}
		printf("Line %d had \t%d/100000 miss ratio with %d lines\n", func[x],(count), secondSetLines);

	}
	if(getInput(NULL)!=1)
		goto CASE2;
	break;
	}
	printf("press any key to continue\n");
	getInput(NULL);
	free(es1);
	free(es2);
	free(times);
	return;


}


void turnOffNoise(){
	printf("Turn off Noise!\n");
	fflush(stdout);
	doNoise = false;
	if (pthread_join(rumble_tid_1, NULL)) {
		printf("pthread_join 1 failed\n");
		fflush(stdout);
		return;
	}
	if (pthread_join(rumble_tid_2, NULL)) {
		printf("pthread_join 2 failed\n");
		fflush(stdout);
		return;
	}
	printf("Noise is off\n");
	fflush(stdout);
}
void turnOnNoise(int core1, int offest1, int intensity1 ,int core2, int offest2, int intensity2, int probensity, int probetresh){// todo: remove probensity probetresh

	bzero(rumbleArgs, sizeof(int)*5);
	bzero(rumbleArgs2, sizeof(int)*5);


	doNoise = true;
	rumbleArgs[0] = core1;
	rumbleArgs[1] = offest1;
	rumbleArgs[2] = intensity1;
	rumbleArgs[3] = probensity;
	rumbleArgs[4] = probetresh;

	if (pthread_create(&rumble_tid_1, NULL, &rumble, rumbleArgs)) {
		printf("pthread_create 1 failed\n");
		fflush(stdout);
		return;
	} else {
		printf("Noise #1 is on, intensity: %d, probensity: %d, probetresh: %d \n", intensity1,probensity, probetresh);
	}

	rumbleArgs2[0] = core2;
	rumbleArgs2[1] = offest2;
	rumbleArgs2[2] = intensity2;
	rumbleArgs2[3] = 0;
	rumbleArgs2[4] = 0;
	if (pthread_create(&rumble_tid_2, NULL, &rumble, rumbleArgs2)) {
		printf("pthread_create 2 failed\n");
		fflush(stdout);
		return;
	} else {
		printf("Noise #2 is on,intensity: %d, probensity: %d, probetresh: %d \n", intensity2,probensity, probetresh);
	}


}

void syncSlices(){
	//assuming there is another mastik already open with the same activesets list
	for (int s = 0; s < nslices; s++){
		int set = -1;
		for (int i = s*setsPerSlice; i < s*setsPerSlice + setsPerSlice; i++){
			if (ActiveSets[i] && !ActiveSets[(i+setsPerSlice)%nsets] && !ActiveSets[(i+2*setsPerSlice)%nsets] && !ActiveSets[(i+3*setsPerSlice)%nsets]){
				set = i;
				break;
			}
		}
		int toSlice=-1;
		int minValue = 100;
		for (int i = 0; i < 4; i++){
			float missPercents = monitorSpecificSet(l3,(set + i*setsPerSlice)%nsets, "specificset_res.txt", false);
			if (missPercents < minValue){
				minValue = missPercents;
				toSlice = (s+i)%4;
			}
		}
		printf("Swap slice %d and %d\n",s,toSlice);
		l3_swapslices(l3,s,toSlice);
	}
}
int main(int ac, char **av) {
	delayloop(3000000000U);
	pinToCore(ATTACKER_CORE);
	void * buff = NULL;
	void * buff2 = NULL;
	int rs;
	int attacker_counter = 0;
	int zeroCounter;
	int tmp;
	int intensity_arg1, intensity_arg2;
	int intensity;
	uint64_t t;
	int option, setToMonitor = 0;
	uint64_t AvrMiss;
	//files
	FILE *log,*f_allsetstotalmisses, *f_allsets, *f_specificset, *f_EvictionSets,*f_overkill, *f_suspectedsets, *f_twosets ,* f_specificset_times_before, * f_specificset_times_after;;
	f_allsets = fopen("allsets_res.txt", "w+");
	f_allsetstotalmisses = fopen("allsets_total_misses.txt", "w+");

	f_specificset = fopen("specificset_res.txt", "w+");
	fclose(f_specificset);
	fclose(f_allsetstotalmisses);
	fclose(f_allsets);

	int setIdx = 0;
	int result, *result1,*result2;
	void** lines_array;
	void** linesToRead;
	int sliceNumA = 0,sliceNumB = 0;
	int *res_rank1 = NULL, *res_rank2 = NULL;
	uint16_t *res = calloc(SAMPLES_FOR_ATTACKER, sizeof(uint16_t));
	specific_res = calloc(SPECIFICSET_SAMPLES_LONG, sizeof(uint16_t));
	specific_res_times_before = calloc(SPECIFICSET_SAMPLES_LONG, sizeof(uint64_t));
	specific_res_times_after = calloc(SPECIFICSET_SAMPLES_LONG, sizeof(uint64_t));
	lines = calloc(sizeof(void*),nsets * LINES_PER_SET);
	uint16_t *twosets_res = calloc(SPECIFICSET_SAMPLES*2, sizeof(uint16_t));
	uint setToMonitor_1,setToMonitor_2;
	size_t len = 0;
	uint8_t *probeDirection = calloc(NSETS, sizeof(uint8_t));
	pid_t pid;
	int rumbleCores = 1;
	void * lineAddr1, *lineAddr2;
	int distance;
	int probensity,probetresh;
	/* get the process id */

	if ((pid = getpid()) < 0)
		perror("unable to get pid");
	else
		printf("The process id is %d\n", pid);
	void * p;

	//socket
	int clientSocket;
	char buffer[1024];
	struct sockaddr_in serverAddr;
	socklen_t addr_size;
	int port;
	int settmp;

	res_rank1 = NULL;
	res_rank2 = NULL;
	ActiveSets = NULL;

	//----------
	CacheMapping();

	goto WHILE; //skip this
	//	for (int sliceForSync = 0; sliceForSync < 1; sliceForSync++){
	int sliceForSync = 0;
	int setForSync = 100 + setsPerSlice*sliceForSync;
	CacheMapping();
	ActiveSets[setForSync] = 1;
	NumOfActiveSets++;
	turnOnNoise(RUMBLE_CORE_0,0,1,RUMBLE_CORE_1,6,0,0,0);
	sleep(1);
	int toSet=-1;
	int minValue = 100;
	float missPercents;
	for(int i = 0; i < 4; i ++){
		missPercents = monitorSpecificSet(l3_test,100 + i*setsPerSlice, "specificset_res.txt", false);
		if (missPercents < minValue){
			minValue = missPercents;
			toSet = i;
		}
	}
	turnOffNoise();
	sleep(1);
	printf("Swap slice %d and %d\n",sliceForSync,toSet);
	l3_swapslices(l3_test,sliceForSync,toSet);
	ActiveSets[setForSync] = 0;
	NumOfActiveSets--;
	printf("Press any key...\n");
	getInput(NULL);
	fflush(stdout);
	//	}
	checkLRU();

	WHILE:
	while (true) {
		printf("--------------------------\n");
		printf("NumOfActiveSets: %d, Sample Interval: %d,%d,%d,%d, Mode:%s\n",NumOfActiveSets, INTERVAL, SIGNAL_ACTIVE_INTERVAL, SIGNAL_SLEEP_INTERVAL,NUM_OF_SIGNAL_CYCLES,automated ? "Automate" : "Manual");
		printf("Please select an option \n");
		printf("1) Map the Cache\n");
		//		printf("2) Ranking I\n");
		//		printf("3) Ranking II\n");
		//		printf("4) Find suspects as attacker\n");
		printf("5) Monitor specific set as attacker\n");
		printf("6) Noise I\n");
		printf("7) Turn off Noise I\n");
		printf("8) Save EvictionSet Mapping to file\n");
		printf("9) Dummy Ranking\n");
		printf("10) Monitor Overkill\n");
		printf("11) Add set to suspect list from file\n");
		printf("12) Add set to suspect list\n");
		printf("13) Remove set from suspect list\n");
		printf("14) Monitor Overkill - on suspect only\n");
		printf("15) Monitor parallely two sets \n");
		printf("16) Print active sets list\n");
		printf("17) Swap Between two slices\n");
		//		printf("18) Change sample interval\n");
		//		printf("19) Probe set\n");
		//		printf("20) Experiment\n");
		printf("21) Signal Active Lines\n");
		printf("22) Cancel Signal Active Lines\n");
		printf("23) Connect & Turn on automatic mode\n");
		printf("24) Turn on automated mode\n");
		printf("25) Turn off automated mode\n");
		//		printf("26) Experiment - Stride\n");
		printf("29) sync slices\n");
		printf("--------------------------\n");
		fflush(stdout);

		if (automated){
			bzero(buffer,sizeof(char) * 1024);
			printf("> ");
			fflush(stdout);
			rs = recv(clientSocket , buffer , 1024 , 0);
			if (rs <= 0){
				perror("recv");
				automated = false;
				printf("changed to manual mode\n");
			} else
				printf("Data received: %s\n",buffer);
		}
		option = getInput(buffer);

		switch (option) {
		case 1:
			CacheMapping();
			break;
		case 2:
			if (!res_rank1)
				res_rank1 = (int*) calloc(nsets, sizeof(int));
			else
				bzero(res_rank1,nsets * sizeof(int));
			printf("Ranking I!\n");
			fflush(stdout);

			countMisses(res_rank1);

			putchar('\n');
			printf("Ranking I Done! Please Start the Victim for Ranking II\n");
			fflush(stdout);
			break;
		case 3:
			if (!res_rank2)
				res_rank2 = (int*) calloc(nsets, sizeof(int));
			else
				bzero(res_rank2,nsets * sizeof(int));
			printf("Ranking II!\n");
			fflush(stdout);
			bzero(ActiveSets, nsets * sizeof(uint8_t));
			NumOfActiveSets = 0;
			f_allsetstotalmisses = fopen("allsets_total_misses.txt", "w+");

			countMisses(res_rank2);

			putchar('\n');
			for (int i = 0; i < nsets; i++) {
				int diff = res_rank2[i] - res_rank1[i];
				fprintf(f_allsetstotalmisses, "%d,%d,%d,%d\n", i, res_rank1[i],	res_rank2[i], diff);
			}

			fclose(f_allsetstotalmisses);
			printf("\nRanking II done! Results file (allsets_total_misses.txt) updated\n");
			fflush(stdout);

			break;
		case 4:
			printf("Find suspects as attacker!\n");
			fflush(stdout);
			f_allsets = fopen("allsets_res.txt", "w+");
			for (int k = 0; k < ATTACKER_PHASES; k++){
				for (int i = 0; i < nsets; i++) {
					l3_unmonitorall(l3);
					l3_monitor(l3, i);

					printf("\rMonitor phase %d [%.2f%]", k,	(double) k / ATTACKER_PHASES * 100);
					fflush(stdout);

					l3_repeatedprobecount(l3, SAMPLES_FOR_ATTACKER/ATTACKER_PHASES, res, INTERVAL);

					for (int j = 0; j < SAMPLES_FOR_ATTACKER/ATTACKER_PHASES; j++) {
						char c;
						int16_t r = (int16_t) res[j];
						switch (r) {
						case 0:
							c = '0';
							break;
						case -1:
							c = '-';
							break;
						default:
							c = '1';
						}
						fprintf(f_allsets, "%c", c);
					}
					fprintf(f_allsets, "\n");
				}
			}
			fclose(f_allsets);
			printf("\n");
			printf("Find suspects as attacker done!\n");
			fflush(stdout);
			break;
		case 5:
			printf("Monitor specific set!\n");
			printf("Select set num: ");
			fflush(stdout);
			setToMonitor = getInput(NULL);
			if (automated){
				token = strtok(NULL, " ");
				monitorSpecificSet(l3,setToMonitor, token, false);
			} else {
				monitorSpecificSet(l3,setToMonitor, "specificset_res.txt", true);
			}
			break;
		case 6:
			if (doNoise){
				printf("doNoise = true, pause the noise and try again\n");
				break;
			}
			printf("Noise I!\n");


			/*
			puts("Which kind of rumble?\n0 - BruteForce\n1 - Complement to intensity\n2 - probe i.o\n3 - probe r.o");
			rumbleOpt = getInput(NULL);

			if (!rumbleOpt){
				puts("Enter set id for probe");
				setForProbe = getInput(NULL);
				rumbleCores = 1;
			} else {
				puts("How much cores? (1/2)");
				rumbleCores = getInput(NULL);
			}
			if (rumbleOpt == 2 || rumbleOpt == 3){
				puts("Enter probensity");
				probensity = getInput(NULL);
				puts("Enter probe threshold");
				probethresh = getInput(NULL);
			}
			 */

			puts("Enter intensity #1");
			intensity_arg1 = getInput(NULL);

			puts("Enter intensity #2");
			intensity_arg2 = getInput(NULL);

			//			puts("Enter probensity"); //todo: remove
			//			probensity = getInput(NULL);//todo: remove
			//
			//			puts("Enter probetresh");//todo: remove
			//			probetresh = getInput(NULL);//todo: remove

			turnOnNoise(RUMBLE_CORE_0,0,intensity_arg1,RUMBLE_CORE_1,6,intensity_arg2, probensity,probetresh);

			break;
		case 7:
			turnOffNoise();
			break;
		case 8:
			f_EvictionSets = fopen("EvictionSets.txt", "w+");
			uint64_t line;
			for (int i = 0; i < nsets; i++) {
				fprintf(f_EvictionSets, "Set %d\n", i);
				for (int j = 0; j < LINES_PER_SET; j++) {
					line = l3_getline(l3, i, j);
					fprintf(f_EvictionSets, "%lx (%d)\n", line,
							(int) ((line >> 6) & 0x7ff));
				}
			}
			fclose(f_EvictionSets);
			break;
		case 9:
			NumOfActiveSets = 0;
			bzero(ActiveSets, nsets * sizeof(uint8_t));
			srand(rdtscp());
			for (int i = 0; i < NUM_OF_ACTIVE_SETS; i++){
				tmp = rand() % NSETS;
				if (ActiveSets[tmp]){
					i--;
					continue;
				}
				ActiveSets[tmp] = true;
				NumOfActiveSets++;
			}
			printf("NumOfActiveSets = %d\n", NumOfActiveSets);
			break;
		case 10:
			log = fopen("log.txt","w+");
			if (stat("./overkill_all", &st) == -1) {
				mkdir("./overkill_all", 0700);
			}

			for (int set = 0; set < nsets; set++) {
				sprintf(str,"./overkill_all/set_%d.txt",set);
				fprintf(log,"%d, %.2f\n",set,monitorSpecificSet(l3,set,str,false));
				fflush(log);
			}
			printf("\n");
			fclose(log);
			break;
		case 11:
			setIdx = 0;
			printf("Add sets to suspect list from file: \n");
			f_suspectedsets = fopen("suspected_sets_num.txt", "r+");
			bzero(input,INPUTSIZE);
			while ((fscanf(f_suspectedsets,"%d", &setIdx))) {
				if(setIdx==-1) break;
				ActiveSets[setIdx] = 1;
				NumOfActiveSets++;
			}
			fclose(f_suspectedsets);
			break;
		case 12:
			setIdx = 0;
			printf("Add set to suspect list:\n");
			fflush(stdout);
			setIdx = getInput(NULL);

			if (setIdx < 0 || setIdx >= nsets) {
				printf("invalid set number!\n");
				break;
			}
			if (ActiveSets[setIdx]) {
				printf("Already a suspect!\n");
				break;
			} else {
				ActiveSets[setIdx] = 1;
				NumOfActiveSets++;
			}
			break;

		case 13:
			setIdx = 0;
			printf("Remove set to suspect list: ");
			fflush(stdout);
			setIdx = getInput(NULL);
			if (setIdx == -1){
				NumOfActiveSets = 0;
				bzero(ActiveSets, nsets * sizeof(uint8_t));
				printf("Removed all!\n");
				break;
			}
			if (setIdx < 0 || setIdx >= nsets) {
				printf("invalid set number!\n");
				break;
			}
			if (!ActiveSets[setIdx]) {
				printf("Not a suspect!\n");
				break;
			} else {
				ActiveSets[setIdx] = 0;
				NumOfActiveSets--;
			}
			break;
		case 14:
			if (stat("./overkill_selected", &st) == -1) {
				mkdir("./overkill_selected", 0700);
			}
			for (int set = 0; set < nsets; set++) {
				if(ActiveSets[set]){
					sprintf(str,"./overkill_selected/set_%d.txt",set);
					monitorSpecificSet(l3,set,str,false);
				}
			}
			printf("\n");
			break;
		case 15:
			printf("Monitor two sets!\n");
			printf("Select set 1 num: ");
			fflush(stdout);
			setToMonitor_1 = getInput(NULL);

			if (setToMonitor_1 < 0 || setToMonitor_1 >= nsets) {
				printf("invalid set number!\n");
				break;
			}

			printf("Select set 2 num: ");
			fflush(stdout);
			setToMonitor_2 = getInput(NULL);
			if (setToMonitor_2 < 0 || setToMonitor_2 >= nsets) {
				printf("invalid set number!\n");
				break;
			}


			if (automated) {
				token = strtok(NULL, " ");
				f_twosets = fopen(token, "w+");
			} else {
				f_twosets = fopen("twosets_res.txt", "w+");
			}

			l3_unmonitorall(l3);
			l3_monitor(l3, setToMonitor_1);
			l3_monitor(l3, setToMonitor_2);
			l3_repeatedprobecount(l3, SPECIFICSET_SAMPLES, twosets_res,INTERVAL);
			for (int j = 0; j < SPECIFICSET_SAMPLES*2; j++) {
				int16_t r = (int16_t) twosets_res[j];
				fprintf(f_twosets, "%d ", r);
			}
			fclose(f_twosets);
			l3_unmonitorall(l3);
			break;
		case 16:
			printf("Suspected Sets:\n");
			f_suspectedsets = fopen("suspected_sets_num.txt", "w+");
			for (int i = 0; i < nsets; i++) {
				if (!(i % 2048))
					printf("\n%d-%d:\n", i, i + 2047);
				if (ActiveSets[i]) {
					fprintf(f_suspectedsets, "%d\n", i);
					printf("%d, ", i);
				}

			}
			printf("\n");
			fprintf(f_suspectedsets, "-1");
			fclose(f_suspectedsets);

			fflush(stdout);
			break;
		case 17:
			sliceNumA = 0;
			sliceNumB = 0;
			printf("Swap Slices!\n");
			printf("Select slice A num (0-%d): ",nslices-1);
			fflush(stdout);
			sliceNumA = getInput(NULL);
			if (sliceNumA < 0 || sliceNumA >= nslices) {
				printf("invalid slice number!\n");
				break;
			}

			printf("Select slice B num (0-%d): ",nslices-1);
			fflush(stdout);
			sliceNumB = getInput(NULL);

			if (sliceNumB < 0 || sliceNumB >= nslices) {
				printf("invalid slice number!\n");
				break;
			}

			l3_swapslices(l3,sliceNumA,sliceNumB);
			break;
		case 18:
			printf("Enter sample interval: \n");
			fflush(stdout);
			tmp = getInput(NULL);
			if (tmp != -1)
				INTERVAL = tmp;

			printf("Enter active signal interval: \n");
			fflush(stdout);
			tmp = getInput(NULL);
			if (tmp != -1)
				SIGNAL_ACTIVE_INTERVAL = tmp;


			printf("Enter sleep signal interval: \n");
			fflush(stdout);
			tmp = getInput(NULL);
			if (tmp != -1)
				SIGNAL_SLEEP_INTERVAL = tmp;

			printf("Enter num of cycles to signal: \n");
			fflush(stdout);
			tmp = getInput(NULL);
			if (tmp != -1)
				NUM_OF_SIGNAL_CYCLES = tmp;

			if (INTERVAL < 0) {
				printf("invalid number!\n");
				break;
			}
			break;

		case 19:
			setIdx = 0;
			printf("Probe set!\n");
			printf("Select set num: ");
			fflush(stdout);
			setIdx = getInput(NULL);

			if (setIdx < 0 || setIdx >= nsets) {
				printf("invalid set number!\n");
				break;
			}
			p = sethead(l3,setIdx);

			printf( "Set:\n", setIdx);
			for (int j = 0; j < LINES_PER_SET; j++) {
				line = l3_getline(l3, setIdx, j);
				clflush(line);
				printf("%lx - %li (%d)\n", line, line,
						(int) (((uint64_t)line >> 6) & 0x7ff));
			}

			result = probeDirection[setIdx] ? probecount(p) : bprobecount(p);
			probeDirection[setIdx] = !probeDirection[setIdx];
			printf("first probe = %d Misses\n",result);
			result = probeDirection[setIdx] ? probecount(p) : bprobecount(p);
			probeDirection[setIdx] = !probeDirection[setIdx];
			printf("second probe = %d Misses\n",result);
			break;
		case 20:
			lineAddr1 = 0;
			lineAddr2 = 0;
			printf("Probe Line!\n");
			printf("Type Set Num: ");
			setIdx = getInput(NULL);

			result1 = (int*)calloc(21,sizeof(int));
			result2 = (int*)calloc(21,sizeof(int));
			lineAddr1 = l3_getline(l3, setIdx, rand()%LINES_PER_SET);
			for (distance = -10; distance<=10; distance++){
				lineAddr2 = (void*)((uint64_t)((uint64_t)lineAddr1 + distance*64));
				setToMonitor_1 = (((uint64_t)lineAddr1)) >> 6 & 0x7ff;
				setToMonitor_2 = (((uint64_t)lineAddr2)) >> 6 & 0x7ff;

				for (int i = 0; i < EXPERIMENT_RUNS; i ++){
					clflush(lineAddr2);
					clflush(lineAddr1);
					result = memaccesstime(lineAddr1);
					result1[distance+10] += result;
					result = memaccesstime(lineAddr2);
					result2[distance+10] += result;

				}
			}
			for (distance = -10; distance<=10; distance++){
				result1[distance+10] = result1[distance+10] / (EXPERIMENT_RUNS);
				result2[distance+10] = result2[distance+10] / (EXPERIMENT_RUNS);
				printf("distance = %d, result1 = %d, result2 = %d\n",distance,result1[distance+10],result2[distance+10]);
			}
			free(result1);
			free(result2);
			break;

		case 21:
			if (doSignal){
				printf("doSignal = true, pause the signal and try again\n");
				break;
			}
			//			printf("Signal!\n");
			doSignal = true;
			printf("write signal times to file?\n");
			writeSignalTimesToFile = getInput(NULL);
			if (writeSignalTimesToFile){
				if (automated){
					token = strtok(NULL, " ");
					strcpy(path,token);
					if (stat(path, &st) == -1) {
						mkdir(path, 0700);
					}
					token = strtok(NULL, " ");
					sprintf(signalFileName,"%s/%s",path,token);
				} else {
					strcpy(signalFileName,"signaltimes.txt");
				}
				printf("Signal, times will be written in %s\n",signalFileName);
			}
			if (pthread_create(&signal_tid, NULL, &signalActiveLines, NULL)) {
				printf("pthread_create failed\n");
				fflush(stdout);
				break;
			}
			printf("Signal is on\n");
			fflush(stdout);

			break;
		case 22:
			printf("Turn off Signal!\n");
			fflush(stdout);
			doSignal = false;
			if (pthread_join(signal_tid, NULL)) {
				printf("pthread_join failed\n");
				fflush(stdout);
				break;
			}
			printf("Signal is off\n");
			fflush(stdout);
			break;
		case 23:

			/*---- Create the socket. The three arguments are: ----*/
			/* 1) Internet domain 2) Stream socket 3) Default protocol (TCP in this case) */
			clientSocket = socket(PF_INET, SOCK_STREAM, 0);
			/*---- Configure settings of the server address struct ----*/
			/* Address family = Internet */
			serverAddr.sin_family = AF_INET;
			/* Set port number, using htons function to use proper byte order */
			printf("Port: ");
			fflush(stdout);
			port = getInput(NULL);
			printf("port = %d\n",port);
			serverAddr.sin_port = htons(port);
			/* Set IP address to localhost */
			serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
			/* Set all bits of the padding field to 0 */
			memset(serverAddr.sin_zero, '\0', sizeof serverAddr.sin_zero);
			/*---- Connect the socket to the server using the address struct ----*/
			addr_size = sizeof serverAddr;
			for (int i = 0; i < 10 && !automated; i++){
				rs = connect(clientSocket, (struct sockaddr *) &serverAddr, addr_size);
				if (rs < 0){
					perror("connect");
					sleep(1);
					continue;
				}
				automated = true;
				printf("Connected! \n");
			}
			break;
		case 24:
			automated = true;
			break;
		case 25:
			automated = false;
			break;
		case 26:
			log = fopen("log.txt","w+");

			buff = 	mmap(NULL, STRIDE_BUFFSIZE, PROT_READ | PROT_WRITE,
					MAP_ANONYMOUS | MAP_PRIVATE | HUGEPAGES, -1, 0);
			printf("toc %d\n",rdtscp64()-t);
			if (buff == MAP_FAILED){
				printf("MAP_FAILED");
				break;
			}

			printf("memory allocated\n");

			printf("Evict all? 1/0\n");
			tmp = getInput(NULL);
			if (tmp){
				printf("%d\n",EvictLLC(l3));
				printf("%d\n",EvictLLC(l3));
				printf("%d\n",EvictLLC(l3));
			}

			printf("Press enter to continue...\n");
			tmp = getInput(NULL);

			result1 = (int*)calloc(STRIDE_LINES,sizeof(int));
			lines_array = (void**)calloc(STRIDE_LINES,sizeof(void*));
			linesToRead = (void**)calloc(20,sizeof(void*));

			printf("random? 2/1/0\n");
			tmp = 0;//getInput(NULL);

			for (int j = 0; j < EXPERIMENT_RUNS; j++){
				lineAddr1 = buff;	// + STRIDE_BUFFSIZE - 64;
				for (int i = 0; i < 300000; i ++){
					clflush(buff + i);
				}
				delayloop(30000U);
				if(tmp == 0){
					for (int i = 0; i < STRIDE_LINES; i++){
						//						lines_array[i] = lineAddr1;

						result1[i] = memaccesstime(lineAddr1);
						lineAddr1 = (void*)((uint64_t)lineAddr1 + 10*64);
						if (lineAddr1 > buff + 300000 && tmp == 0){
							printf("%d",i);
							tmp = 99;
						}
					}
				}

				if (tmp == 1){
					printf("tmp = 1");
					fflush(stdout);
					for (int i = 0; i < STRIDE_LINES; i ++){
						srand(rdtscp());
						for (int k = 0; k < 1; k++){
							linesToRead[k] = buff + (rand()%rdtscp64()) % (STRIDE_BUFFSIZE);
						}

						t = rdtscp64();
						for (int k = 0; k < 1; k++){
							memaccess(linesToRead[k]);
						}
						result = rdtscp64() - t;
						result1[i] = result/1;
					}
				}

				if (tmp == 2){
					for (int i = 0; i < STRIDE_LINES; i ++){
						srand(rdtscp());
						lines_array[i] = lineAddr1;
						//						printf("%lx,",lineAddr1);
						result1[i] = memaccesstime(lineAddr1);
						lineAddr1 = (void*)((uint64_t)lineAddr1 + (3+rand()%3)*(8*sizeof(void*)));
					}
				} 

			}

			for (int i = 0; i < STRIDE_LINES; i ++){
				fprintf(log,"%d,",result1[i]);
			}

			printf("\n");
			fflush(stdout);
			free(result1);
			free(linesToRead);
			free(lines_array);
			fclose(log);
			tmp = getInput(NULL);
			printf("Press enter to release pages\n");
			munmap(buff, STRIDE_BUFFSIZE);

			break;
		case 27:
			log = fopen("log.txt","w+");;
			buff = 	mmap(NULL, 50*1024*1024, PROT_READ | PROT_WRITE,
					MAP_ANONYMOUS | MAP_PRIVATE | HUGEPAGES, -1, 0);
			if (buff == MAP_FAILED){
				printf("MAP_FAILED");
				break;
			}
			printf("memory allocated\n");

			result1 = (int*)calloc(STRIDE_LINES,sizeof(int));
			lines_array = (void**)calloc(STRIDE_LINES,sizeof(void*));
			linesToRead = (void**)calloc(20,sizeof(void*));

			//			buff = (uint64_t)buff | ( << 6);
			printf("add2set = %d\n",((uint64_t) buff >> 6) & 0x7ff);
			tmp = 1 << 17;
			while(1){
				//				printf("%lx\n",buff + tmp);
				//				t = rdtscp64();
				//				clflush(buff + tmp);
				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				memaccess(buff + tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				result = (rdtscp64() - t)/30;
				//				result = memaccesstime(buff+tmp); tmp = (tmp + 1 << 17) & 0x1ffffff;
				//				fprintf(log,"%d,",result);

			}

			for (int i = 0; i < STRIDE_LINES; i ++){
				fprintf(log,"%d,",result1[i]);
			}

			printf("\n");
			fflush(stdout);
			free(result1);
			free(linesToRead);
			free(lines_array);
			fclose(log);
			munmap(buff, STRIDE_BUFFSIZE);
			break;
		case 28:
			checkLRU();

			break;
		case 29:
			syncSlices();
			break;
		case 30:
			printf("Enter set number\n");
			setToMonitor = getInput(NULL);
			result_filename = strtok(NULL, " ");
			result_times_before_filename = strtok(NULL, " ");
			result_times_after_filename = strtok(NULL, " ");
			l3_unmonitorall(l3);
			l3_monitor(l3, setToMonitor);
			sprintf(path,"/media/ben/FE54580F5457C8D3/results_case30/set_%d",setToMonitor);
			if (stat(path, &st) == -1) {
				mkdir(path, 0700);
			}

			for(int i=0;i<LINES_PER_SET;i++){

				fflush(stdout);

				l3_repeatedprobecountbyline(l3, SPECIFICSET_SAMPLES, specific_res,specific_res_times_before,specific_res_times_after,INTERVAL, setToMonitor, i);

				sprintf(str,"%s/%s_%d.txt",path,result_filename,i);
				f_specificset = fopen(str, "w+");

				sprintf(str,"%s/%s_%d.txt",path,result_times_before_filename,i);
				f_specificset_times_before = fopen(str, "w+");

				sprintf(str,"%s/%s_%d.txt",path,result_times_after_filename,i);
				f_specificset_times_after  = fopen(str, "w+");

				for (int j = 0; j < SPECIFICSET_SAMPLES; j++) {
					int16_t r = (int16_t) specific_res[j];

					if (r < 13 && r > 0)
						AvrMiss += (uint16_t) r;
					if (!r)
						zeroCounter++;
					if (r != -1){
						r = (r > 140);
					}
					fprintf(f_specificset, "%d ", r);
					fprintf(f_specificset_times_before, "%li ", specific_res_times_before[j]);
					fprintf(f_specificset_times_after,  "%li ", specific_res_times_after[j]);
				}

				fclose(f_specificset);
				fclose(f_specificset_times_before);
				fclose(f_specificset_times_after);
			}
			fileNum++;
			break;

		case 31:
			printf("Enter set number\n");
			setToMonitor = getInput(NULL);
			result_filename = automated ? strtok(NULL, " ") : "";
			result_times_after_filename = automated ? strtok(NULL, " ") : "";

			if (!automated){
				result_filename = calloc(100,sizeof(char));
				result_times_after_filename = calloc(100,sizeof(char));
				sprintf(result_filename,"attacker_results_%d",attacker_counter);
				sprintf(result_times_after_filename ,"attacker_times_results_%d",attacker_counter);
				attacker_counter++;
			}

			l3_unmonitorall(l3);
			l3_monitor(l3, setToMonitor);
			if (automated)
				sprintf(path,"/media/ben/FE54580F5457C8D3/results_case31/set_%d",setToMonitor);
			else
				sprintf(path,"/media/ben/FE54580F5457C8D3/results_case31/");

			if (stat(path, &st) == -1) {
				mkdir(path, 0700);
			}
			fflush(stdout);

			l3_repeatedprobecount_with_times(l3, SPECIFICSET_SAMPLES_LONG, specific_res,specific_res_times_after,INTERVAL);

			sprintf(str,"%s/%s.txt",path,result_filename);
			f_specificset = fopen(str, "w+");

			sprintf(str,"%s/%s.txt",path,result_times_after_filename);
			f_specificset_times_after  = fopen(str, "w+");

			for (int j = 0; j < SPECIFICSET_SAMPLES_LONG; j++) {
				int16_t r = (int16_t) specific_res[j];
				fprintf(f_specificset, "%d ", r);
				fprintf(f_specificset_times_after,  "%li ", (!j) ? specific_res_times_after[j] : specific_res_times_after[j]-specific_res_times_after[j-1]);
			}
			fflush(f_specificset);
			fclose(f_specificset);
			fclose(f_specificset_times_after);
//			goto NOACK;
			break;

		case 32:

			//			bzero(rumbleArgs2, sizeof(int)*3);
			//
			//
			//			doNoise = true;
			//			rumbleArgs[0] = core1;
			//			rumbleArgs[1] = offest1;
			//			rumbleArgs[2] = intensity1;
			//			if (pthread_create(&rumble_tid_1, NULL, &rumble, rumbleArgs)) {
			//				printf("pthread_create 1 failed\n");
			//				fflush(stdout);
			//				return;
			//			} else {
			//				printf("Noise #1 is on\n");
			//			}
			bzero(rumbleArgs, sizeof(int)*3);

			if (doSignal){
				printf("doSignal = true, pause the signal and try again\n");
				break;
			}
			//			printf("Signal!\n");
			doSignal = true;
			printf("signal id?\n");
			rumbleArgs[0] = getInput(NULL);
			printf("signal intensity?\n");
			rumbleArgs[1] = getInput(NULL);
			printf("write signal times to file?\n");
			writeSignalTimesToFile = getInput(NULL);
			if (writeSignalTimesToFile){
				if (automated){
					token = strtok(NULL, " ");
					strcpy(path,token);
					if (stat(path, &st) == -1) {
						mkdir(path, 0700);
					}
					token = strtok(NULL, " ");
					sprintf(signalFileName,"%s/%s",path,token);
				} else {
					printf("filname?\n");
					scanf("%s",signalFileName);
				}
				printf("Signal, times will be written in %s\n",signalFileName);
			}
			if (pthread_create(&signal_tid, NULL, &signalActiveLines_ForNoise, rumbleArgs)) {
				printf("pthread_create failed\n");
				fflush(stdout);
				break;
			}
			printf("Signal is on\n");
			fflush(stdout);

			break;
		case 33:
			if (doSignal){
				printf("doSignal = true, pause the signal and try again\n");
				break;
			}
			//			printf("Signal!\n");
			doSignal = true;
			printf("write signal times to file?\n");
			writeSignalTimesToFile = getInput(NULL);
			if (writeSignalTimesToFile){
				if (automated){
					token = strtok(NULL, " ");
					strcpy(path,token);
					if (stat(path, &st) == -1) {
						mkdir(path, 0700);
					}
					token = strtok(NULL, " ");
					sprintf(signalFileName,"%s/%s",path,token);
				} else {
					strcpy(signalFileName,"signaltimes.txt");
				}
				printf("Signal, times will be written in %s\n",signalFileName);
			}
			if (pthread_create(&signal_tid, NULL, &signalActiveLines_viaForloop, NULL)) {
				printf("pthread_create failed\n");
				fflush(stdout);
				break;
			}
			printf("Signal is on\n");
			fflush(stdout);

			break;
		}
		if (automated && option!=23){
			sprintf(buffer,"ack %d",option);
			rs = send(clientSocket,buffer,strlen(buffer),0);
			if (rs <= 0){
				perror("send");
				automated = false;
				printf("changed to manual mode\n");
			}
		}
		NOACK:
		option = option;
	}

	CLOSE:

	fclose(f_allsets);
	fclose(f_specificset);
	free(res);
	free(specific_res);
	free(ActiveSets);
	free(lines);
	if (res_rank1)
		free(res_rank1);
	if (res_rank2)
		free(res_rank2);
	l3_release(l3);
}

int pointerToEnd;
